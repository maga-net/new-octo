{
  "readme_content": "# new-octo: A Proof-of-Stake Validator Node Simulator\n\nThis repository contains a Python-based simulator for a Proof-of-Stake (PoS) blockchain network. It models the core lifecycle of validator nodes, including block proposal, peer validation, and consensus achievement. Its modular architecture clearly illustrates the interactions between different components of a decentralized system.\n\n## Concept\n\nIn a Proof-of-Stake blockchain, network security is maintained by validators who stake their own cryptocurrency as collateral. Unlike Proof-of-Work, which requires solving complex computational puzzles, PoS selects validators to create new blocks based on factors like the size of their stake and randomization.\n\nThis simulation abstracts away low-level networking and cryptography to focus on the high-level logic of the PoS consensus mechanism.\n\n## Features\n\nThe simulation models and demonstrates the following core concepts:\n\n-   **Stake-Weighted Proposer Selection**: A validator is chosen to propose the next block, with higher-staked nodes having a greater chance.\n-   **Block Creation**: The selected proposer gathers pending transactions and creates a new block.\n-   **Peer Validation**: Other validators in the network receive and verify the integrity of the proposed block.\n-   **Consensus via Attestation**: Validators \"vote\" (attest) for a valid block. A block is finalized once it achieves a supermajority (e.g., > 2/3 of the total stake).\n-   **Failure Handling**: The simulation can model edge cases like a proposer going offline or a block failing to reach consensus.\n\n## Code Architecture\n\nThe simulator is built with a clear, object-oriented structure to separate concerns. Each class has a distinct responsibility:\n\n-   `Transaction`: A simple data class representing a single transaction with a sender, recipient, and amount.\n-   `Block`: Represents a block in the chain. It contains a list of transactions, a timestamp, its own hash, and the hash of the previous block, linking the chain together.\n-   `Validator`: The core actor in the simulation. Each `Validator` instance represents a node in the network with a unique address and a specific `stake`. It has methods to `propose_block` and `validate_block`.\n-   `Blockchain`: Manages the state of the chain itself. It holds the list of confirmed blocks (`chain`) and a pool of `pending_transactions` waiting to be included in the next block.\n-   `PoSConsensus`: The engine that orchestrates the consensus protocol. It uses the list of validators and the current blockchain state to `select_proposer` and conduct a `run_consensus_round`, where it manages the validation and voting process.\n-   `SimulationManager`: The top-level class that initializes and runs the entire simulation. It sets up the network of validators, generates random transactions to simulate activity, and loops through a configurable number of consensus rounds.\n\nThe interaction flows as follows:\n`SimulationManager` -> `PoSConsensus` -> `Validator` -> `Block` & `Transaction`\n\n## How it Works\n\nA single consensus round, which aims to add one new block to the chain, proceeds as follows:\n\n1.  **Generate Activity**: The `SimulationManager` creates a set of random transactions and adds them to the `Blockchain`'s pending pool.\n2.  **Select Proposer**: The `PoSConsensus` engine runs its `select_proposer` method. This performs a stake-weighted random choice from the list of all active `Validators`.\n3.  **Propose Block**: The selected `Validator` is tasked with creating a new `Block`. It takes the pending transactions from the `Blockchain`, bundles them, adds the necessary metadata (index, previous hash), and calculates the block's hash.\n4.  **Broadcast & Validate**: The simulation broadcasts this new block to all other `Validators` in the network. Each validator then independently runs its `validate_block` method to check for correctness:\n    -   Is the block index correct?\n    -   Does the `previous_hash` match the last block in their known chain?\n    -   Is the block's own hash valid?\n5.  **Attest (Vote)**: If a validator finds the block to be valid, it \"attests\" to it. In the simulation, this means its stake is added to a running total of `attesting_stake` for the current round.\n6.  **Finalize Block**: After all validators have checked the block, the `PoSConsensus` engine compares the `attesting_stake` against the total stake in the network. If it exceeds the consensus threshold (e.g., 66.7%), the block is considered finalized.\n7.  **Update Chain**: The `Blockchain` object's `add_block` method is called, officially adding the new block to the chain and clearing the pending transactions that were included.\n8.  **New Round**: The simulation proceeds to the next round, starting again from step 1. If consensus was not reached, the block is discarded, and a new round begins with a new proposer.\n\n## Getting Started\n\nThe script is self-contained and requires no external Python libraries. To run the simulation, save the code as `pos_simulation.py` and execute it from your terminal:\n\n```bash\npython pos_simulation.py\n```\n\n### Simulation Output\n\nYou will see verbose output that tracks the simulation's progress in real-time:\n\n```\n--- Setting up Simulation Environment ---\n  -> Initialized Validator 1: Address=6b86b273ff..., Stake=320.45\n  -> Initialized Validator 2: Address=d4735e3a26..., Stake=150.12\n...\n--- Setup Complete ---\n\nðŸš€ --- Starting PoS Blockchain Simulation --- ðŸš€\n\n==================== ROUND 1/5 ====================\n\nSIMULATION: Generated 5 new transactions for the next block.\n--- Starting Consensus Round for Block Index 1 ---\nCONSENSUS: Selected 6b86b273ff... as the next block proposer (Stake: 320.45).\nVAL-6b86b2: Proposing new block at index 1...\nCONSENSUS: Block 1 proposed. Broadcasting for validation...\nVAL-d4735e: Validating block 1 proposed by 6b86b2...\n  -> VALIDATION SUCCESS: Block 1 is valid.\n  -> VAL-d4735e: Attesting to block 1. Adding stake of 150.12.\n...\nCONSENSUS: Total attesting stake: 2540.78 / 2810.90\nCONSENSUS: Supermajority reached! Block is finalized.\n\nCHAIN: âœ… Block 1 successfully added to the blockchain.\nCHAIN: New chain length: 2\n\n...\n==================== SIMULATION FINISHED ====================\n\n--- Final Blockchain State ---\n{\n  \"index\": 0,\n  ...\n}\n{\n  \"index\": 1,\n  ...\n}\n...\n\n--- Simulation Summary ---\nTotal Rounds Simulated: 5\nSuccessful Rounds (Blocks Added): 5\nFailed Rounds: 0\nFinal Chain Length: 6\n```\n\n### Configuration\n\nYou can easily configure the simulation by modifying the constants at the bottom of the script. For example, to change the number of validators or consensus rounds:\n\n```python\nif __name__ == \"__main__\":\n    # --- Simulation Configuration ---\n    NUMBER_OF_VALIDATORS = 10\n    NUMBER_OF_ROUNDS = 5\n\n    # --- Run Simulation ---\n    manager = SimulationManager(\n        num_validators=NUMBER_OF_VALIDATORS\n    )\n    manager.run(num_rounds=NUMBER_OF_ROUNDS)\n```"
}